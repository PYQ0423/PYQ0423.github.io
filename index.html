<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-March14杂记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/14/March14%E6%9D%82%E8%AE%B0/" class="article-date">
  <time datetime="2020-03-14T10:57:32.845Z" itemprop="datePublished">2020-03-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/14/March14%E6%9D%82%E8%AE%B0/">March14杂记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>又到了一天的老时候。</p>
<p>这是沉迷学习的一个月，尤其是最近这3周，所有的娱乐活动都停止了，全心全意地在准备计算机的东西。</p>
<p>今天把算法、JAVA、操作系统等若干笔记都整理归类了一波。之前虽然也有归类，但来源比较散。这次是把笔记都按主题来分类，更便于查找和发现体系上的缺漏。</p>
<p>这可能就是所谓的知识体系吧。真是踏破铁鞋无觅处，经过这两个月沉下心的学习，我算是建立了一套属于自己的计算机知识体系。之后工作，就可以在这个体系之上添砖加瓦。建立这个体系确实花费了我大量的时间。因为知识天然确实是零散的，即使不是零散的知识，也需要把它放到一个更大的框架里，才能发挥更大的作用。</p>
<p><img src="..%5Cimages%5C%E6%88%91%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB.png" alt="我的计算机知识体系"></p>
<p>但在建立了知识体系之后，就会更容易发现它的漏洞。本来一团乱麻的，看不出什么问题；整理归类了，反而会发现自己这也不懂，那也不懂的。要努力补上呀~</p>
<p>最后记录一个趣闻，今晚吃猪蹄，我爸给我留了一块栗子肉，就是指结实又肥嫩的肉，肉中的精品。然后我呢，慢悠悠地，也不把它驾到自己碗里，而是在大菜碗一点点吃。然后，我妈出现了，大叫着这肉真不错，然后夹走了它。我当时的第一反应是，临界资源被抢走了。现在想想，我采用的大概是乐观锁的机制，也不对“关键对象”加锁（夹到碗里）。然后，就被别人捷足先登了。</p>
<p>另外，也希望自己能成为一个更关心别人、更柔软的人。BTW，冥想和瑜伽需配套练习，效果更佳。</p>
<p>明天希望可以全面得过一遍算法题，写出代码，并且把它们归类。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/14/March14%E6%9D%82%E8%AE%B0/" data-id="ck7rlmz5p0000kgvlbc8sf7w7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-March13" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/13/March13/" class="article-date">
  <time datetime="2020-03-13T13:36:52.003Z" itemprop="datePublished">2020-03-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/13/March13/">March13</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>今天又是学习的一天，但也略有不同，每天都能get到新的点。</p>
<p>今天想到一个比较有意思的点，计算机、瑜伽和音乐，这三个领域，可以作为终身追求的目标。计算机是工作，也是理性和逻辑的代表；瑜伽和音乐是兴趣，是工作之余的调节；瑜伽偏重生理，音乐偏重心理。三者结合，是比较完美的状态。</p>
<h3 id="计算机科学"><a href="#计算机科学" class="headerlink" title="计算机科学"></a>计算机科学</h3><h4 id="通过练习动态规划，对递归执行流的理解更深入了"><a href="#通过练习动态规划，对递归执行流的理解更深入了" class="headerlink" title="通过练习动态规划，对递归执行流的理解更深入了"></a>通过练习动态规划，对递归执行流的理解更深入了</h4><p>今天一直在看动态规划，题目中经常会出现循环里带递归，是之前从未见过的。比如，打印八皇后的摆法，或是求出箱子堆最高的高度。这两个问题都是有很多种递归的情况组成的，单靠一个递归只能解决一种情况，在外面还要套一个for循环，才能遍历所有的情况。</p>
<p>今天也算是感受到了一些肉眼编译器的能力。递归其实也没有那么复杂，需要重点关注的是：传入的变量，出口，执行流，和这个函数到底是在干啥。最后一个尤其重要，就是昨天杂记里谈到的定性认识。有时候想要全程追踪执行流虽然可行，但是过于繁琐了。可能习惯了一些范式之后，就能更容易上升到定性的程度吧。</p>
<h4 id="树的前序、中序和后序"><a href="#树的前序、中序和后序" class="headerlink" title="树的前序、中序和后序"></a>树的前序、中序和后序</h4><p>今天也看了关于树和图的算法。了解到所谓前序、中序、后序，是适用于树的一种说法，而深度优先和广度优先是树与图均可以使用的术语。使用前序、中序还是后序，由问题的性质决定。前序是最先处理根节点，并不是所有的问题都适用这样的逻辑，比如你想要知晓一个文件系统中磁盘块的占用情况，那么在得到根节点的情况之前，显然要先求解它左右孩子的情况。这样的问题，就不适用于前序遍历，而适用后序遍历。</p>
<p>同样的，后序遍历是会最后处理根节点。假设我们想要按照层次深度打印出一个目录结构，每深一层，就往里缩进一个tab。这种情况下，使用后序遍历就不合适，而是应该先处理根节点，输出，然后递归左右孩子。</p>
<h4 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h4><p>贪心是参看了《数据结构与算法分析 JAVA语言实现》的第10章算法设计技巧。里面讲到了3个例子，分别是短作业优先算法、哈夫曼编码和近似装箱问题。觉得很有意思的是，哈夫曼编码居然和ties树有关联，都是字母在叶子节点的树；另外，装箱问题还分为联机装箱和脱机装箱，前者是内存分配问题的抽象，解决它经常是操作系统里常见的一些算法，比如首次适应，最佳适应什么的。真是条条大路通操作系统啊。</p>
<h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><p>Cookie是服务器用来查找用户状态的关键字。HTTP无状态，所以服务器端只能通过把状态在数据库里存储，再提取出来，才知道之前的结果。就像是一个记性只有5秒钟的人，尬笑。</p>
<p>HTTP的方法是客户端对服务器端发送的命令，而其中个人感觉比较靠谱的，只有四个方法：GET、HEAD、CONNECT和OPTIONS，而POST、DELETE、PUT和TRACE都存在安全隐患，所以不太常用。</p>
<h3 id="瑜伽"><a href="#瑜伽" class="headerlink" title="瑜伽"></a>瑜伽</h3><h4 id="第一次尝试了阿斯汤伽腿部序列"><a href="#第一次尝试了阿斯汤伽腿部序列" class="headerlink" title="第一次尝试了阿斯汤伽腿部序列"></a>第一次尝试了阿斯汤伽腿部序列</h4><p>阿斯汤伽可以说是瑜伽的老祖宗，是非常正统的瑜伽流派。要说缺点，可能就是难度太高，而且对体能有所要求。而我就喜欢挑战嘛！所以在昨天尝试了热身序列后，今天果断尝试了腿部序列，全长28min。</p>
<p>做完双腿十分绵软，不过确实体会到了双腿坚实发力的感觉。在多套动作间交错体会，是最好的提高方式~</p>
<h4 id="神猴哈努曼式"><a href="#神猴哈努曼式" class="headerlink" title="神猴哈努曼式"></a>神猴哈努曼式</h4><p>神猴哈努曼式进展比较缓慢，可能也是因为这几天压力比较大，身体比较僵紧。慢慢来吧~我的目标是今年之内能做到标准。</p>
<h3 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h3><p>疲劳但要做事的时候爱听交响乐，精力充沛却容易瞎想时候喜欢听古琴。这两个在我看来是处于同一个段位的高雅艺术。幸运现在如此方便就能获得资源。</p>
<p>我永远爱K271和交响情人梦 :)</p>
<h3 id="明日计划"><a href="#明日计划" class="headerlink" title="明日计划"></a>明日计划</h3><ol>
<li>搞定栈与队列、链表和位操作。</li>
<li>整合现有题目。</li>
<li>有时间的话巩固排序算法。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/13/March13/" data-id="ck7q9tq3x00000gvl9zd93p9s" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-March12杂记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/12/March12%E6%9D%82%E8%AE%B0/" class="article-date">
  <time datetime="2020-03-12T13:52:08.311Z" itemprop="datePublished">2020-03-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/12/March12%E6%9D%82%E8%AE%B0/">March12杂记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>categories: 杂记</p>
<p>今天是一年一度的植树节，记得小学的时候植树节还会跑出去种树呢，是个郊游的好机会。</p>
<p>不过今天其实又是学习的一天。找工作真是残酷，把你的无能放在太阳下暴晒，然后你发现没有办法只能变强。</p>
<p>JAVA、操作系统、数据库都已经挨个问过了，第三轮一定会问网络。字节跳动公司测开岗的难度还是挺高的，对基础知识问得很深，算法也不是傻缺难度，至少也是个Mediem。</p>
<p>今天算法的部分看了图的、树整理了一半，哈希整理完了，参考书是《数据结构与算法分析 JAVA语言描述》。这本书写得很好，一来它里面大部分不是伪代码，而是真实的JAVA代码；二来它经常会结合JDK的库来说算法和数据结构，就很有意思。</p>
<p>今天看算法书上写二叉排序树的删除算法，对递归又有新的认识。递归不仅要定量地理解，也要定性地理解。递归，就是自己调用自己，所以返回是属于同一个类型。我原本总是沉浸在定量中，去一层一层思考递归到第几层了，逻辑对不对。但实际上，只用考虑返回的这个值是个什么含义，就可以了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> BinaryNode&lt;AnyType&gt; <span class="title">remove</span><span class="params">(AnyType x, BinaryNode&lt;AnyType&gt; t)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> t;</span><br><span class="line">       <span class="keyword">int</span> compareResult = x.compareTo(t.element);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (compareResult &lt; <span class="number">0</span>)</span><br><span class="line">           t.left = remove(x, t.left);</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (compareResult &gt; <span class="number">0</span>)</span><br><span class="line">           t.right = remove(x, t.right);</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (t.left != <span class="keyword">null</span> &amp;&amp; t.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">           t.element = findMin(t.right).element;</span><br><span class="line">           t.right = remove(t.element, t.right);</span><br><span class="line">       &#125; <span class="keyword">else</span></span><br><span class="line">           t = (t.left != <span class="keyword">null</span>) ? t.left : t.right;</span><br><span class="line">       <span class="keyword">return</span> t;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>瞧这if else if else的结构，一看就是事先把情况都分析清楚了。事实上执行分为3大类型：向左走、向右走和找到。而找到之后，根据其没有孩子/有一个孩子/有两个孩子，又可以分为三种情况，其中第一种和第二种情况在代码里进行了合并。</p>
<p>非常值得一提的是<code>t.right = remove(t.element, t.right);</code> 这句代码。是个递归调用没错，但是理解它的更好的方式是从含义上理解，由于remove方法实现的功能就是从某棵树中删除某个节点，因此我们可以直接拿来使用，并赋给当前节点的右子树。</p>
<p>JAVA并发编程，看了第三章共享对象。《JAVA并发编程》这本书写得极好，原本死记硬背的零零散散的知识，可以借助书上的逻辑给串起来。</p>
<p>作为一个程序员，总是要假设最坏的情况会发生。就像是并发编程里的竞争条件，或是对象逸出。</p>
<p>《图解HTTP》看了第一章和第二章，感觉最大的收获是理解了HTTP请求和响应的机理。然后才明白为什么面试喜欢问请求的方法和响应的状态码，这两个确实很重要，就像谈判时候两个人的立场，旗帜鲜明。</p>
<p>最后的最后，我今天把hexo迁移到本地了，github提交居然没有冲突，真是出乎我的意料。不早了，晚安。~</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/12/March12%E6%9D%82%E8%AE%B0/" data-id="ck7otap700000fwvl9qe7h3qf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-浅谈数据结构中那些容易混淆的概念" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/12/%E6%B5%85%E8%B0%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E9%82%A3%E4%BA%9B%E5%AE%B9%E6%98%93%E6%B7%B7%E6%B7%86%E7%9A%84%E6%A6%82%E5%BF%B5/" class="article-date">
  <time datetime="2020-03-12T13:26:13.541Z" itemprop="datePublished">2020-03-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/12/%E6%B5%85%E8%B0%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E9%82%A3%E4%BA%9B%E5%AE%B9%E6%98%93%E6%B7%B7%E6%B7%86%E7%9A%84%E6%A6%82%E5%BF%B5/">浅谈数据结构中那些容易混淆的概念</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文旨在记录笔者发觉的计算机科学中容易混淆的数据结构和概念，希望对读者也有所帮助。</p>
<p>每种数据结构都有自己独特的应用场景和适用范围，并没有可以通吃一切的数据结构。</p>
<h3 id="二叉树和自平衡二叉树"><a href="#二叉树和自平衡二叉树" class="headerlink" title="二叉树和自平衡二叉树"></a>二叉树和自平衡二叉树</h3><p>你知道BST和AVL最本质的区别吗?</p>
<p>观察维基百科对树的分类，笔者发现了一个有意思的地方，维基百科将树分为二叉树、自平衡二叉查找树、B树、堆、Trie树，还有一些我不太熟悉的树种。其中，二叉树又包含二叉查找树BST，自平衡二叉查找树包含AVL树、红黑树等。二叉树和自平衡二叉树两者的区别是什么呢？</p>
<p>二叉树的关注点往往是它的遍历方式、存储方式，而自平衡二叉树往往更注重它的操作，比如旋转、插入、删除、查询前驱、查询后继等。其中，平衡二叉树又叫AVL树，是最早被发明的自平衡二叉查找树。该树的名称来源于该数据结构的两位发明人的名称首字母缩写。而红黑树具有最好的最坏情况运行时间，故在实践中经常被用到。</p>
<pre><code>二叉排序树是指一棵空树，或是具有这样性质的二叉树：
1. 若左子树非空，则左子树上的所有节点值均小于其根节点
2. 若右子树非空，则右子树上的所有节点值均大于其根节点
3. 左右子树也分别递归满足1和2条件</code></pre><p>注意此处并没有规定平衡性，只强调了节点值的大小比较。所以，二叉排序树并不需要是平衡的，因此它的查找性能也未必能够得到保证。</p>
<p>换句话说，在实践中常用的往往是自平衡的二叉树，因为它们的平均性能和最坏性能更好，而二叉树，包括BST，往往只停留在理论研究的水平。</p>
<h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/12/%E6%B5%85%E8%B0%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E9%82%A3%E4%BA%9B%E5%AE%B9%E6%98%93%E6%B7%B7%E6%B7%86%E7%9A%84%E6%A6%82%E5%BF%B5/" data-id="ck7osjkq100037svldf4vefft" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-March10杂记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/12/March10%E6%9D%82%E8%AE%B0/" class="article-date">
  <time datetime="2020-03-12T13:26:13.434Z" itemprop="datePublished">2020-03-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/12/March10%E6%9D%82%E8%AE%B0/">March10杂记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>categories: 杂记</p>
<p>刚把手机VPN配置好了，觉得有点小成就感。顺便记录下上周字节跳动二面的一小段回忆。</p>
<p>前几天与字节跳动的面试官的一段对话对我产生了深远的影响。摘录如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我：为什么面试要考算法呢？</span><br><span class="line">面试官：你觉得呢？</span><br><span class="line">我：我之前问过另一个面试官，他的意思是，算法是一个筛人的方法，因为人太多了。</span><br><span class="line">面试官：（感觉不太认同的样子）我的观点和他有点不同。出一道算法题其实是在观察你如何解决一个问题，或者是难题。因为我们的实际工作中就是在不停地解决问题。</span><br></pre></td></tr></table></figure>

<p>事后，我回味他的回答，觉得说得很好，但也容易被反驳。</p>
<p>算法，我觉得更像是一种套路的积累，是需要刻意练习的。反复做自己已经掌握了的点，对水平并无增长。学会现成的、证明有用的套路，在面试的时候展现出来即可。</p>
<p>但也存在另一种情况，那就是这道题你还真没碰到过。出现这种情况，往往是因为你积累得还不够多，或者说不全面。在这种情况下，就真的是查看你解决难题的能力了。</p>
<p>总是从简单的例子开始，逐步扩大，观察规律。比如我这次被问到的“集合的子集问题”，我当时想到的是用递归来做。事后去看题解确实也可以用递归来解，但当时不知怎么一紧张，思路没有出来。所以真的需要提醒自己，从简单的例子开始，总结规律。</p>
<p>不过面试的时候，往往只会有极短的思考时间。因此，真的是功夫在平时。</p>
<p>说回手机VPN的事情。我购买的服务本身就支持多台设备，但因为国区这里的SSR软件都被墙了，所以就没有那么straightforward的方法，之前就放弃了。但今天忽然就有了干劲想搞一波。</p>
<p>先是查了一个Youtube视频教程，下载了一个Beta版本的SSR软件。结果发现确实需要付费，25块钱一个月。不值得，果断回溯。</p>
<p>发现Github中有一个iPhone翻墙教程，还挺详细的。其实就是通过电脑数据线，在手机上装一个老版本的SSR软件。</p>
<p>下载软件之后，扫描服务器节点的二维码就能连上了。</p>
<p>虽然寥寥几句话，但确实也花了我40来分钟的时间。期间一直都很想找小伙伴求助，但想想这个事情也挺繁琐的，估计也没有一键解决的方案；更何况我都是要当程序员的人了，这么点难题还要找人帮忙，以后在职场上怎么混。于是咬咬牙确实也被我搞出来了。</p>
<p>这倒也不是个人英雄主义什么的，该请教别人的时候还是要问的。</p>
<p>以上。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/12/March10%E6%9D%82%E8%AE%B0/" data-id="ck7osjkpu00007svl5mdi7eub" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-基础算法杂记第一篇" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/12/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%9D%82%E8%AE%B0%E7%AC%AC%E4%B8%80%E7%AF%87/" class="article-date">
  <time datetime="2020-03-12T13:26:13.432Z" itemprop="datePublished">2020-03-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/12/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%9D%82%E8%AE%B0%E7%AC%AC%E4%B8%80%E7%AF%87/">基础算法杂记第一篇</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>categories: 算法</p>
<p>本文是基础算法系列第一篇文章。文中包含7个算法实现，大部分题目出自剑指offer，难度都是偏简单的题型，但也有一些有意思的思路在其中。</p>
<ol>
<li>JDK中实现的二分查找算法</li>
</ol>
<ul>
<li>除以二以右移1位代替</li>
<li>下标的变化处理放在前面，分支的判断放在后面</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该方法为私有方法，是内部调用，故没有边界检查</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch0</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = fromIndex;</span><br><span class="line">    <span class="keyword">int</span> high = toIndex - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> midVal = a[mid];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (midVal &lt; key)</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (midVal &gt; key)</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> mid; <span class="comment">// key found</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -(low + <span class="number">1</span>);  <span class="comment">// key not found.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br />

<ol start="2">
<li>建立二叉树<br>输入一个层序遍历的结果数组，输出一个二叉树的根节点。若节点为空，则数组中使用Integer.MAX_VALUE表示。</li>
</ol>
<ul>
<li>使用递归的方法实现。</li>
<li>新建一个递归函数，传递下标的做法很典型。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">buildUpTree</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    TreeNode root = buildUpTree(arr, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> TreeNode <span class="title">buildUpTree</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    TreeNode cur;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &lt; arr.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] == Integer.MAX_VALUE)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        cur = <span class="keyword">new</span> TreeNode(arr[i]);</span><br><span class="line">        cur.left = buildUpTree(arr, <span class="number">2</span> * i + <span class="number">1</span>);</span><br><span class="line">        cur.right = buildUpTree(arr, <span class="number">2</span> * i + <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br />

<ol start="3">
<li>面试题21：调整数组顺序使奇数位于偶数前面</li>
</ol>
<ul>
<li>只需要一层循环，且在最外层规定循环条件。</li>
<li>如果满足条件，直接continue进入下一个。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] exchange(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = nums.length - <span class="number">1</span>;  <span class="comment">// two pointers</span></span><br><span class="line">        <span class="keyword">int</span> tmp;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; i &lt; nums.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] % <span class="number">2</span> == <span class="number">1</span>) &#123; <span class="comment">// 如果nums[i]是个奇数，则忽略</span></span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] % <span class="number">2</span> == <span class="number">0</span>) &#123; <span class="comment">// 如果nums[j]是个偶数，则忽略</span></span><br><span class="line">                j--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp = nums[i];</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">            nums[j] = tmp;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<br />

<ol start="4">
<li>面试题52：两个链表节点的第一个公共节点</li>
</ol>
<p>做法一：Set保存一个链表的节点，然后用另一个链表的节点循环核实。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        HashSet&lt;ListNode&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (headA != <span class="keyword">null</span>) &#123;</span><br><span class="line">            set.add(headA);</span><br><span class="line">            headA = headA.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(headB != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(headB)) &#123;</span><br><span class="line">                <span class="keyword">return</span> headB;</span><br><span class="line">            &#125;</span><br><span class="line">            headB = headB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>做法二：双指针法的做法很有意思，其中涉及了一个数学关系：A’ + R = A ; B’ + R = B ; A’ + R + B’ = A + B’ = A’ + B ; 其中 R 是重复部分。A‘ 和 B’ 是各链表的开头不重复的部分。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode_2pointers</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       ListNode pA = headA, pB = headB;</span><br><span class="line">       <span class="keyword">while</span> (pA != pB) &#123;</span><br><span class="line">           <span class="keyword">if</span> (pA == <span class="keyword">null</span>)</span><br><span class="line">               pA = headB;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               pA = pA.next;</span><br><span class="line">           <span class="keyword">if</span> (pB == <span class="keyword">null</span>)</span><br><span class="line">               pB = headA;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               pB = pB.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> pA;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<br />

<ol start="5">
<li>面试题15：二进制中1的个数</li>
</ol>
<ul>
<li>按位与操作，和1相与。操作符为&amp;</li>
<li>右移操作，操作符为&gt;&gt;=</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">                count++;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>; <span class="comment">// 左边的用原有标志位补充，右边超出的部分舍弃。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<br>

<p>6.1 面试题06：从头到尾打印链表</p>
<p>看到逆序输出，第一反应就是栈。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">       <span class="comment">// use stack</span></span><br><span class="line">       Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">       <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">           stack.push(head);</span><br><span class="line">           head = head.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[stack.size()];</span><br><span class="line">       <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">           result[index] = stack.pop().val;</span><br><span class="line">           index++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>6.2 面试题24：反转链表</p>
<ul>
<li>如果从栈中取出直接用，那么会保留原来的指针</li>
<li>因此也可以这样写：先把取出节点的后继置为空，然后再加入新的链表</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> head;</span><br><span class="line">       <span class="comment">// use stack</span></span><br><span class="line">       Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">       <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">           stack.push(head);</span><br><span class="line">           head = head.next;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       head = stack.pop();</span><br><span class="line">       ListNode cur = head;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">           <span class="comment">// 如果从栈中取出直接用，那么会保留原来的指针</span></span><br><span class="line">           cur.next = <span class="keyword">new</span> ListNode(stack.pop().val); </span><br><span class="line">           <span class="comment">// 因此也可以这样写：先把取出节点的后继置为空，然后再加入新的链表</span></span><br><span class="line">           <span class="comment">// stack.peek().next = null; </span></span><br><span class="line">           <span class="comment">// cur.next = stack.pop();</span></span><br><span class="line">           cur = cur.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> head;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/12/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E6%9D%82%E8%AE%B0%E7%AC%AC%E4%B8%80%E7%AF%87/" data-id="ck7osjkpz00017svlciqcfise" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-浅谈二叉树的DFS和BFS" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/08/%E6%B5%85%E8%B0%88%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84DFS%E5%92%8CBFS/" class="article-date">
  <time datetime="2020-03-08T00:24:25.000Z" itemprop="datePublished">2020-03-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/08/%E6%B5%85%E8%B0%88%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84DFS%E5%92%8CBFS/">浅谈二叉树的DFS与BFS</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="树的遍历方法"><a href="#树的遍历方法" class="headerlink" title="树的遍历方法"></a>树的遍历方法</h3><p>树的遍历方法总得来说有两种，深度优先遍历和广度优先遍历。这两种方法都可以用来解决大部分树的算法题。本文想要总结一下这两种方法的区别和联系。</p>
<h3 id="树的广度优先遍历"><a href="#树的广度优先遍历" class="headerlink" title="树的广度优先遍历"></a>树的广度优先遍历</h3><p>广度优先遍历，顾名思义，是指按照深度依次向下，每次都会进行横向的处理。广度优先遍历也不是一定会使用队列的，使用的数据结构并不能解决算法是一个DFS还是一个BFS，两者最本质的区别在于BFS是横向处理节点的，每次都会把与当前节点相关联的节点加入数据结构中，而DFS是纵向处理的，对每个节点都会沿着路径一路走到空为止，然后再回退。</p>
<p>广度优先遍历的处理流程如下：<br>    1. 根节点入队\栈<br>    2. 进入循环，退出条件为队列为空。<br>    [2.1 对当前的层次进行循环操作][层序遍历专属]<br>        2.2 出队<br>        2.3 如果出队的节点有左孩子，则加入队列<br>        2.4 如果出队的节点有右孩子，则加入队列</p>
<p>如果是层序遍历，那么广度优先遍历会是双重循环，而先序/中序/后序遍历，只需一层循环即可。也很能理解为什么层序遍历需要使用两层循环，因为这样的做法可以保证每个外层循环处理一层的节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; levelOrder( TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        Queue&lt; TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> n = queue.size();</span><br><span class="line">            List&lt;Integer&gt; layer = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                layer.add(queue.peek().val);</span><br><span class="line">                root = queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (root.left != <span class="keyword">null</span>)</span><br><span class="line">                    queue.add(root.left);</span><br><span class="line">                <span class="keyword">if</span> (root.right != <span class="keyword">null</span>)</span><br><span class="line">                    queue.add(root.right);</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(layer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>使用层序遍历的思路可以解决很多问题：比如剑指Offer中的第27题，二叉树的镜像；第55题，求二叉树的深度。其中二叉树的镜像是在原始代码的内层循环的最后加入了swap交换，即针对当前节点交换它的左右孩子。由于每次都是交换孩子节点，所以父亲节点的处理顺序并不重要。（因为当前节点的孩子节点进行交换之后，势必会影响孩子节点被处理的顺序。而这个对本题的结果没有影响。）二叉树的深度，就是叶子节点的最大深度。用层序遍历的方式，也可以求出maxDepth。因为层序遍历每次处理一层节点，因此使用一个记录变量res，每次内层循环迭代结束，res就自增，然后进入下一层。</p>
<p>树的后序遍历是先序/中序/后序这三种遍历中最复杂的，它使用广度优先搜索的算法解析如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">posOrder</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Node&gt; s1 = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">        Stack&lt;Node&gt; s2 = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">        s1.push(head);</span><br><span class="line">        <span class="keyword">while</span> (!s1.isEmpty()) &#123;</span><br><span class="line">            Node cur = s1.pop();</span><br><span class="line">            s2.push(cur);</span><br><span class="line">            <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                s1.push(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                s1.push(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!s2.isEmpty()) &#123;</span><br><span class="line">            Node cur = s2.pop();</span><br><span class="line">            System.out.println(cur.val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>树的后序遍历需要借助两个栈，一个负责最初的加入节点，一个负责结果的逆置，分别设为s1和s2。为什么说s2做的事是逆置？因为最初加入s1时的节点顺序是先左后右，故s1弹出的顺序就会是先右后左。而正常压入s2之后，再弹出的顺序反而又变成了先左后右了，与后序遍历的“左、右、中”的优先级一致。</p>
<p>那么，为什么根节点是最后输出的呢？因为比起它的孩子节点，根节点总是最先被s1弹出的，也是最先被s2压入的。换句话说，层次越靠上层的节点，越早被s1弹出，在s2中的位置也就越靠近底层。</p>
<h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><p>如果你使用递归来求解树的问题，其实天然就使用了深度优先遍历的方法。深度优先遍历，常用栈作为节点路径的存储结构，因为栈的天然属性符合深度优先遍历的特色，即FILO（First In Last Out）。具体到树的算法中，深度优先遍历总是从根节点开始，然后把子节点压入栈中。一般习惯的处理方式是先左后右（无论是先序、中序还是后序，改变的只是根节点的处理顺序，但左子节点始终在右节点之前处理）。</p>
<p>先序遍历和中序遍历有一点需要注意的地方，那就是中序遍历和先序遍历都既可以用广度优先遍历求解，也可以用深度优先遍历求解。广度优先遍历就是每次都会同时考察当前节点的左子树和右子树，并将其加入队列/栈。而深度优先遍历则是在当前节点不为空的情况下，沿着树一路向左走到底，直到子节点为空；然后将栈顶节点出栈（这时它就是最靠左的节点），将其赋值为它的右孩子；然后继续进行之前的向左走循环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**二叉树的非递归中序遍历*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Node&gt; s = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!s.isEmpty() || head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">                s.push(head);</span><br><span class="line">                head = head.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                head = s.pop();</span><br><span class="line">                System.out.println(head.val);</span><br><span class="line">                head = head.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>






















      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/08/%E6%B5%85%E8%B0%88%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84DFS%E5%92%8CBFS/" data-id="ck7osjkq000027svl6tzs0oal" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/" rel="tag">树的遍历</a></li></ul>

    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/" rel="tag">树的遍历</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/" style="font-size: 10px;">树的遍历</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/03/14/March14%E6%9D%82%E8%AE%B0/">March14杂记</a>
          </li>
        
          <li>
            <a href="/2020/03/13/March13/">March13</a>
          </li>
        
          <li>
            <a href="/2020/03/12/March12%E6%9D%82%E8%AE%B0/">March12杂记</a>
          </li>
        
          <li>
            <a href="/2020/03/12/%E6%B5%85%E8%B0%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E9%82%A3%E4%BA%9B%E5%AE%B9%E6%98%93%E6%B7%B7%E6%B7%86%E7%9A%84%E6%A6%82%E5%BF%B5/">浅谈数据结构中那些容易混淆的概念</a>
          </li>
        
          <li>
            <a href="/2020/03/12/March10%E6%9D%82%E8%AE%B0/">March10杂记</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>